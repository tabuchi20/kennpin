async function scan() {
    if (scanning) return;
    scanning = true;
    try {
        const constraints = {
            video: {
                facingMode: "environment",
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = stream;

        if (mode === "hinban") {
            // canvasで枠内だけ切り取る
            const frame = document.getElementById("scan-frame");
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            // 枠のサイズをcanvasに設定
            canvas.width = frame.offsetWidth;
            canvas.height = frame.offsetHeight;

            // videoの映像を枠内に合わせて描画
            const rect = frame.getBoundingClientRect();
            const videoRect = videoElement.getBoundingClientRect();
            const scaleX = videoElement.videoWidth / videoRect.width;
            const scaleY = videoElement.videoHeight / videoRect.height;

            ctx.drawImage(
                videoElement,
                (rect.left - videoRect.left) * scaleX,
                (rect.top - videoRect.top) * scaleY,
                rect.width * scaleX,
                rect.height * scaleY,
                0,
                0,
                rect.width,
                rect.height
            );

            // ここでcanvasから読み取る
            const luminanceSource = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
            const binaryBitmap = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(luminanceSource));
            const result = codeReader.decode(binaryBitmap);
            handleScan(result.text);
        } else {
            // 通常検品は全体から
            const result = await codeReader.decodeOnceFromVideoDevice(undefined, 'v');
            handleScan(result.text);
        }

        stopCamera();
    } catch (e) {
        alert("読み取り失敗: " + e.message);
        stopCamera();
    }
}
